%Candidate Number: 23844
%Last Modified: 12/12/2024

clear all;
close all;

% setting the parameters for questions 15 to 17

s=2;                        % proliferation rate for cells with ecDNA
M=100;                      % total number of simulations
t_final=8;                  % the max simulation time
max_k=150;                  % maximum number of ecDNA copies to track
max_cells=1000000;          % large number
t_p=0:0.2:t_final;          % time points to measure N_k(t). setting it to
% 0.2 as opposed to 0.1 as in questions 6-14
% to reduce the complexity of the simulation
t_points=length(t_p);       % determining how many time points we have
% for array initialisations

% pre-allocatinng an array for the simulation loop
N=zeros(M,max_k+1,t_points);    % tracks the N_k(t_final)

% setting up the loop for stochastic simulation
for m = 1:M
    % initialising arrays and other parameters for the while loop
    cell_pop=zeros(1,max_cells); % tracks the cell population over the loop
    cell_pop(1)=1;     % initialising with one cell containing one ecDNA
    num_real_cells=1;  % track actual number of cells
    t=0;               % setting starting time to 0
    t_idx=1;           % time step checker

    while t<t_final
        % setting up the proliferation rates
        rates=1+(cell_pop(1:num_real_cells)>0)*(s-1);
        total_rate=sum(rates);

        % establishing time updates using Gillespie's algorithm
        dt=exprnd(1/total_rate);
        t=t+dt;

        % calculating N at the time intervals
        while t_idx<t_points && t>=t_p(t_idx+1)
            % counting the amount of cells with each ecDNA count
            count=histcounts(cell_pop(1:num_real_cells),0:(max_k+1));
            N(m,:,t_idx)=count;
            % updating the time step
            t_idx=t_idx+1;
        end

        % randomly choosing a parent cell to divide via weighted sampling
        chosen_cell=randsample(1:num_real_cells,1,true,rates);
        parent_ecDNA=cell_pop(chosen_cell);

        if parent_ecDNA>0
            % per the division process, doubling the ecDNA count within
            % parent cell
            doubled_ecDNA=2*parent_ecDNA;
            % using binomial distribution to allocate how many of ecDNA
            % copies go into the first daughter cell
            daughter1_ecDNA=binornd(doubled_ecDNA, 1/2);
            % with the rest going into the second daughter cell
            daughter2_ecDNA=doubled_ecDNA-daughter1_ecDNA;
        else
            % if the parent cell does not have any ecDNA, it just splits
            daughter1_ecDNA=0;
            daughter2_ecDNA=0;
        end

        % updating the cell population
        cell_pop(chosen_cell)=daughter1_ecDNA;
        cell_pop(num_real_cells+1)=daughter2_ecDNA;

        % increasing the number that tracks the total amount of cells
        num_real_cells=num_real_cells+1;
    end
    % since the simulation might end early, ensuring that N_k(t_final) is
    % accounted for
    if t_idx==t_points
        count=histcounts(cell_pop(1:num_real_cells),0:(max_k+1));
        N(m,:,t_idx)=count;
    end
    disp(['the simulation ',num2str(m), ' out of ', num2str(M), ' has been completed.']);
end

%% (Question 15)
% calculating the proportions over the entire simulated data
proportions=N./sum(N,2);

% as the question doesn;t specify the time at which we take proportions, we
% assume that it is over both simulation and time points, thus we take
% average proportions over both
avg_proportions=mean(mean(proportions(:,:,:),1),3);

% getting std errors over each time point
std_temp=std(proportions, 0, 1);
% calculating std errors across all the time points
std_err=squeeze(mean(std_temp,3)/sqrt(M));

% plotting the average cell proportions pk(t) over the number of ecDNA
% copies k
figure(1);
bar(0:(length(avg_proportions)-1), avg_proportions);
% looking only at the first 50 samples as was instructed
axis ([0 50 0 max(avg_proportions)+0.05]);
% adjusting the x axis for better visibility
xlim([-1 51]);
xlabel('number of ecDNA copies (k)');
ylabel('average cell proportions p_{k}(t)');
title('Distribution of the cell proportions with s=2');
grid on;
hold on;
% adding error bars
errorbar(0:(length(avg_proportions)-1), avg_proportions, std_err, 'k.','LineStyle', 'none');
hold off;

%% (Question 16 & 17)
% initialising M1 and M2 for the for loop
m1 = zeros(M, t_points);    % == M(1)(t)
m2 = zeros(M, t_points);    % == M(2)(t)
k_values = 0:max_k;         % making a vector of k_values

for m = 1:M
    for t = 1:t_points
        % removing the unneccessary dimensions via squeeze
        p_k_t=squeeze(proportions(m,:,t));
        % using formula M(1)(t)=sum(k*pk(t)) to calculate first moment
        m1(m,t)=sum(k_values.*p_k_t);
        % using formula M(2)(t)=sum(k^2*pk(t)) to calculate second moment
        m2(m,t)=sum((k_values.^2).*p_k_t);
    end
end

% calculating the mean values
m1_mean=mean(m1,1);
m2_mean=mean(m2,1);

% plotting the average first moment M(1)(t) over time (t)
figure(2);
plot(t_p, m1_mean,'blue','Linewidth', 1.2);
xlabel ('time (sec)');
ylabel('first moment M^{(1)}(t)');
title('Evolution of the first moment M^{(1)}(t)');
legend('Simulated M^{(1)}(t)');
grid on;

% plotting the average second moment M(2)(t) over time (t)
figure(3);
plot(t_p, m2_mean,'blue','Linewidth', 1.2);
xlabel ('time (sec)');
ylabel('second moment M^{(2)}(t)');
title('Evolution of the second moment M^{(2)}(t)');
legend('Simulated M^{(2)}(t)');
grid on;
